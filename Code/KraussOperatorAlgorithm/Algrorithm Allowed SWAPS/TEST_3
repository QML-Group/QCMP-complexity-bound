import numpy as np
import networkx as nx
import scipy as sp

beta = 2
n=3

##The main change in this iteration is the fact that we will now diagonalise the graph Laplacian when composing the density matrix. 
###Which turns out to give exactly the same

#Functions for the preprocessing and importing of the graphs which we want to use.
#function which converts a Networkx graph to a Laplacian Matrix
def G_LM(x):
    LM = sp.sparse.csr_matrix.toarray(nx.laplacian_matrix(nx.from_numpy_matrix(x)))
    return LM
#function which converts a numpy array of a graph to a density matrix
def rho(x):
    D = np.zeros((n,n))
    for i in range(n):
        D[i][i]=np.linalg.eig(G_LM(x))[0][i]
    rho = sp.linalg.expm(-beta*D)/np.trace((sp.linalg.expm(-beta*D)))
    return rho
#function which determines the Q_jsd for two given density matrices
def Q_jsd(x,y):
    test = (x+y)/2
    s1 = -sum(np.linalg.eig(test)[0]*np.log(np.linalg.eig(test)[0]))
    s2 = -(sum(np.linalg.eig(x)[0]*np.log(np.linalg.eig(x)[0]))+sum(np.linalg.eig(y)[0]*np.log(np.linalg.eig(y)[0])))/2
    f = s1-s2
    return f 

##Read in the set of graphs. This should be changed to the graphs which Median also uses. 
G2 = nx.read_graph6('/Users/s.b.szkudlarek/Documents/1 - Study/MSc/MSc Thesis/Code/Entropy sepctrum all + data/graph3.g6')
G2L = [None]*len(G2)
for i in range(len(G2)):
    G2L[i]=nx.to_numpy_array(G2[i])

#Assign the graphs to the CG and IG 
IG=G2L[3]
CG=G2L[2]

#Optimisation function & constraints
#generate the permutation matrices (PM)
pms = [np.identity(n)]
for j in range(n):
    for i in range(n-j):
        if CG[j][i+j]==1:
            swap_allowed=np.identity(n)
            swap_allowed[i+j][i+j]=0
            swap_allowed[j][j]=0
            swap_allowed[i+j][j]=1
            swap_allowed[j][i+j]=1
            pms.append(swap_allowed)

print(np.trace(np.dot(rho(CG),rho(CG))),np.trace(np.dot(rho(IG),rho(IG))))